# VirtualMemorySimulator

A C# and WPF project that simulates the virtual memory functionality of a computer.


Brief overview.
Virtual memory represents a memory management technique that the operating system uses in order to give the program / the user the false impression / the “illusion” that it can actually access a very large amount of memory, the whole memory of the computer actually. This way, all addresses the program / process accesses are called “virtual addresses”, which are mapped behind by the operating system to actual physical locations of the memory, which are called “physical addresses”. The operating system uses hardware and software resources for this purpose. To translate the virtual addresses to physical addresses, the operating system uses an address translation hardware from the CPU, called memory management unit (MMU). From the software point of view, the operating system may extend the memory given to a process, even beyond the actual limit of the physical limit.
The main operations performed by the virtual memory of a computer are: finding the required information in the RAM memory, placing a page of data from the Disk in the RAM, eventually swapping a page from the RAM to be replaced by another one from the Disk. 


Project structure.
The solution is divided in two projects.

The first one (VirtualMemorySimulator) is for the user interface, for which the WPF framework was used. The windows that can be displayed are the main window, where process details, their page tables, the RAM usage percentage etc., a window for seeing the status of the commands that will be generated during the simulation, a window for seeing the status of the RAM's frames and also a window for configuring the simulation parameters (the number of processes, commands, RAM frames etc.). For a visual representation, see the PNG file from the root folder of this repository. This project depends on the second one (the Machine project). For reducing the amount of user interface code, styles were used, at control level, page level and even application level. 

The second project is a class library developed under the .NET Core 3.1 Framework. It only contains application's logic classes. The most important classes from this project are the OS (operating system) and the MMU (Memory Management Unit). The OS generates all the simulation required objects: processes, their page tables, the commands to be executed etc., then assigns them to the MMU. The MMU takes them one by one, each one being assigned to a Task object. If the page corresponding to the current command is not loaded (the IsValid field of the page is false), then it asks for the OS to load it. If no page can be loaded (the RAM is full) a Page Fault takes place and a page needs to be replaced. The criterion the pirority queue of the pages was build is "replace the one that was used the least used recently", i.e. the one with the smallest last access time. After the page is replaced (if needed), the MMU performs the current operation on the page. If the operation is write, the page is first checked for recent edits (if the dirty bit is true). If true, the edits are first saved to the Disk. Similarly for the page swapping, if the page that follows to be swapped is dirty, it will first be saved back to the disk. Each time the OS needs to access the Disk, a delay with the configured value is used, to simulate the relative longer time OS needs to access the Disk. Between each command execution, a delay is induced, for simulating the OS needing time to switch from one command to the other and also for making the simulation easier to follow and develop slower. When all the operations are done, another simulation can be performed. For the second project, the interclass dependencies were reduced as much as possible, so that minor classes (the Page, for instance) do not depend on higher ones (the OS, for instance), by using Dependency Injection. Only a few classes and properties required for the graphical representation are exposed from this project, most of the components being either internal or private, so that the internal logic is preserved and to ensure high portability in the future.

Because the project uses the Task functionality at an appropriate level, the UI remains responsive during the simulation, each task, delay and other operations performed by the Machine project being placed on a separate Task and eventually assigned to another thread. The project also makes use of events, fired by the Machine project and handled by the VirtualMemorySimulator project, to provide further asynchronous flow to the application.

